// Generated by CoffeeScript 2.3.2
// Extends mocha with a function similar to `it` but 
// running both locally and remotely
var configure, connect;

connect = require('ssh2-connect');

configure = function(...configs) {
  var base, callback_local, callback_remote, config, i, j, len, promise_local, promise_remote, ref, they;
  for (i = j = 0, len = configs.length; j < len; i = ++j) {
    config = configs[i];
    if (config == null) {
      configs[i] = config = {};
    }
    if ((base = configs[i]).name == null) {
      base.name = `${i}.${(!((ref = config.ssh) != null ? ref.host : void 0) ? 'local' : 'remote')}`;
    }
    if (config.ssh === true) {
      configs[i].ssh = {
        host: 'localhost',
        port: 22
      };
    }
  }
  // Local execution for promises
  promise_local = function(context, config, handler) {
    return handler.call(context, {...config});
  };
  // Remote execution for promises
  promise_remote = function(context, config, handler) {
    return new Promise(function(resolve, reject) {
      return connect(config.ssh, function(err, ssh) {
        var close, p;
        close = function(callback) {
          var open, ref1, ref2;
          open = ((ref1 = ssh._sshstream) != null ? ref1.writable : void 0) && ((ref2 = ssh._sock) != null ? ref2.writable : void 0);
          if (!open) {
            return callback();
          }
          ssh.end();
          return ssh.on('end', function() {
            return process.nextTick(function() {
              return callback();
            });
          });
        };
        if (err) {
          return reject(err);
        }
        try {
          p = handler.call(context, {
            ...config,
            ssh: ssh
          }, function(err) {});
        } catch (error) {
          err = error;
          // Sync through throw error
          reject(err);
        }
        // Async through promise
        if (p) {
          return p.then(function() {
            return close(function() {
              return resolve();
            });
          }, function(err) {
            return close(function() {
              return reject(err);
            });
          });
        } else {
          // Sync through return
          return close(function() {
            return resolve();
          });
        }
      });
    });
  };
  // Local execution for callbacks
  callback_local = function(context, config, handler, next) {
    handler.call(context, {...config}, next);
    return null;
  };
  // Remote execution for callbacks
  callback_remote = function(context, config, handler, next) {
    return connect(config.ssh, function(err, ssh) {
      if (err) {
        return next(err);
      }
      return handler.call(context, {
        ...config,
        ssh: ssh
      }, function(err) {
        var open, ref1, ref2;
        open = ((ref1 = ssh._sshstream) != null ? ref1.writable : void 0) && ((ref2 = ssh._sock) != null ? ref2.writable : void 0);
        if (!open) {
          return next();
        }
        ssh.end();
        return ssh.on('end', function() {
          return process.nextTick(function() {
            return next(err);
          });
        });
      });
    });
  };
  // Define our main entry point
  they = function(msg, handler) {
    var k, l, len1, len2, results, results1;
    if (handler.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        results.push((function(config, i) {
          if (!config.ssh) {
            return it(`${msg} (${config.name})`, function() {
              return promise_local(this, config, handler);
            });
          } else {
            return it(`${msg} (${config.name})`, function() {
              return promise_remote(this, config, handler);
            });
          }
        })(config, i));
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        results1.push((function(config, i) {
          if (!config.ssh) {
            return it(`${msg} (${config.name})`, function(next) {
              return callback_local(this, config, handler, next);
            });
          } else {
            return it(`${msg} (${config.name})`, function(next) {
              return callback_remote(this, config, handler, next);
            });
          }
        })(config, i));
      }
      return results1;
    }
  };
  they.only = function(msg, handler) {
    var k, l, len1, len2, results, results1;
    if (handler.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        results.push((function(config, i) {
          if (!config.ssh) {
            return it.only(`${msg} (${config.name})`, function() {
              return promise_local(this, config, handler);
            });
          } else {
            return it.only(`${msg} (${config.name})`, function() {
              return promise_remote(this, config, handler);
            });
          }
        })(config, i));
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        results1.push((function(config, i) {
          if (!config.ssh) {
            return it.only(`${msg} (${config.name})`, function(next) {
              return callback_local(this, config, handler, next);
            });
          } else {
            return it.only(`${msg} (${config.name})`, function(next) {
              return callback_remote(this, config, handler, next);
            });
          }
        })(config, i));
      }
      return results1;
    }
  };
  they.skip = function(msg, handler) {
    var k, l, len1, len2, results, results1;
    if (handler.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        results.push((function(config, i) {
          if (!config.ssh) {
            return it.skip(`${msg} (${config.name})`, function() {
              return promise_local(this, config, handler);
            });
          } else {
            return it.skip(`${msg} (${config.name})`, function() {
              return promise_remote(this, config, handler);
            });
          }
        })(config, i));
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        results1.push((function(config, i) {
          if (!config.ssh) {
            return it.skip(`${msg} (${config.name})`, function(next) {
              return callback_local(this, config, handler, next);
            });
          } else {
            return it.skip(`${msg} (${config.name})`, function(next) {
              return callback_remote(this, config, handler, next);
            });
          }
        })(config, i));
      }
      return results1;
    }
  };
  // Return the final result
  return they;
};

module.exports = configure();

module.exports.configure = function(...configs) {
  return configure(...configs);
};
