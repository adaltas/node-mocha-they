// Generated by CoffeeScript 2.5.1
// Extends mocha with a function similar to `it` but 
// running both locally and remotely
var configure, connect, flatten;

connect = require('ssh2-connect');

flatten = function(arr) {
  var i, j, ref, ret;
  ret = [];
  for (i = j = 0, ref = arr.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
    if (Array.isArray(arr[i])) {
      ret.push(...flatten(arr[i]));
    } else {
      ret.push(arr[i]);
    }
  }
  return ret;
};

configure = function(...configs) {
  var base, callback_local, callback_remote, config, i, j, len, promise_local, promise_remote, ref, they;
  configs = flatten(configs);
  for (i = j = 0, len = configs.length; j < len; i = ++j) {
    config = configs[i];
    if (config == null) {
      configs[i] = config = {};
    }
    if ((base = configs[i]).name == null) {
      base.name = `${i}.${!((ref = config.ssh) != null ? ref.host : void 0) ? 'local' : 'remote'}`;
    }
    if (config.ssh === true) {
      configs[i].ssh = {
        host: 'localhost',
        port: 22
      };
    }
  }
  // Local execution for promises
  promise_local = function(context, config, handler) {
    return handler.call(context, {...config});
  };
  // Remote execution for promises
  promise_remote = async function(context, config, handler) {
    var close, err, ssh;
    ssh = (await connect(config.ssh));
    close = function() {
      return new Promise(function(resolve) {
        var opened, ref1, ref2;
        opened = ((ref1 = ssh._sshstream) != null ? ref1.writable : void 0) && ((ref2 = ssh._sock) != null ? ref2.writable : void 0);
        if (!opened) {
          return resolve();
        }
        ssh.end();
        return ssh.on('end', function() {
          return process.nextTick(function() {
            return resolve();
          });
        });
      });
    };
    try {
      await handler.call(context, {
        ...config,
        ssh: ssh
      });
      return close();
    } catch (error) {
      err = error;
      await close();
      throw err;
    }
  };
  // Local execution for callbacks
  callback_local = function(context, config, handler, next) {
    handler.call(context, {...config}, next);
    return null;
  };
  // Remote execution for callbacks
  callback_remote = function(context, config, handler, next) {
    return connect(config.ssh, function(err, ssh) {
      if (err) {
        return next(err);
      }
      return handler.call(context, {
        ...config,
        ssh: ssh
      }, function(err) {
        var open, ref1, ref2;
        open = ((ref1 = ssh._sshstream) != null ? ref1.writable : void 0) && ((ref2 = ssh._sock) != null ? ref2.writable : void 0);
        if (!open) {
          return next();
        }
        ssh.end();
        return ssh.on('end', function() {
          return process.nextTick(function() {
            return next(err);
          });
        });
      });
    });
  };
  // Define our main entry point
  they = function(msg, handler) {
    var k, l, len1, len2, results, results1;
    if (handler.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        results.push((function(config, i) {
          if (!config.ssh) {
            return it(`${msg} (${config.name})`, function() {
              return promise_local(this, config, handler);
            });
          } else {
            return it(`${msg} (${config.name})`, function() {
              return promise_remote(this, config, handler);
            });
          }
        })(config, i));
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        results1.push((function(config, i) {
          if (!config.ssh) {
            return it(`${msg} (${config.name})`, function(next) {
              return callback_local(this, config, handler, next);
            });
          } else {
            return it(`${msg} (${config.name})`, function(next) {
              return callback_remote(this, config, handler, next);
            });
          }
        })(config, i));
      }
      return results1;
    }
  };
  they.only = function(msg, handler) {
    var k, l, len1, len2, results, results1;
    if (handler.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        results.push((function(config, i) {
          if (!config.ssh) {
            return it.only(`${msg} (${config.name})`, function() {
              return promise_local(this, config, handler);
            });
          } else {
            return it.only(`${msg} (${config.name})`, function() {
              return promise_remote(this, config, handler);
            });
          }
        })(config, i));
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        results1.push((function(config, i) {
          if (!config.ssh) {
            return it.only(`${msg} (${config.name})`, function(next) {
              return callback_local(this, config, handler, next);
            });
          } else {
            return it.only(`${msg} (${config.name})`, function(next) {
              return callback_remote(this, config, handler, next);
            });
          }
        })(config, i));
      }
      return results1;
    }
  };
  they.skip = function(msg, handler) {
    var k, l, len1, len2, results, results1;
    if (handler.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        results.push((function(config, i) {
          if (!config.ssh) {
            return it.skip(`${msg} (${config.name})`, function() {
              return promise_local(this, config, handler);
            });
          } else {
            return it.skip(`${msg} (${config.name})`, function() {
              return promise_remote(this, config, handler);
            });
          }
        })(config, i));
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        results1.push((function(config, i) {
          if (!config.ssh) {
            return it.skip(`${msg} (${config.name})`, function(next) {
              return callback_local(this, config, handler, next);
            });
          } else {
            return it.skip(`${msg} (${config.name})`, function(next) {
              return callback_remote(this, config, handler, next);
            });
          }
        })(config, i));
      }
      return results1;
    }
  };
  // Return the final result
  return they;
};

module.exports = configure();

module.exports.configure = function(...configs) {
  return configure(...configs);
};
