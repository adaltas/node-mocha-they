// Generated by CoffeeScript 2.3.2
// Extends mocha with a function similar to `it` but 
// running both locally and remotely
var configure, connect;

connect = require('ssh2-connect');

configure = function(...configs) {
  var base, callback_local, callback_remote, config, i, j, len, promise_local, promise_remote, they;
  for (i = j = 0, len = configs.length; j < len; i = ++j) {
    config = configs[i];
    if (config == null) {
      configs[i] = config = {};
    }
    if ((base = configs[i]).name == null) {
      base.name = `${i}.${(!config.host ? 'local' : 'remote')}`;
    }
    configs[i].ssh = !!config.host;
  }
  // Local execution for promises
  promise_local = function(context, callback) {
    return callback.call(context, null);
  };
  // Remote execution for promises
  promise_remote = function(context, callback) {
    return new Promise(function(resolve, reject) {
      if (config.host == null) {
        config.host = 'localhost';
      }
      return connect(config, function(err, ssh) {
        var close, p;
        close = function(callback) {
          var open, ref, ref1;
          open = ((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0);
          if (!open) {
            return callback();
          }
          ssh.end();
          return ssh.on('end', function() {
            return process.nextTick(function() {
              return callback();
            });
          });
        };
        if (err) {
          return reject(err);
        }
        try {
          p = callback.call(context, ssh, function(err) {});
        } catch (error) {
          err = error;
          // Sync through throw error
          reject(err);
        }
        // Async through promise
        if (p) {
          return p.then(function() {
            return close(function() {
              return resolve();
            });
          }, function(err) {
            return close(function() {
              return reject(err);
            });
          });
        } else {
          // Sync through return
          return close(function() {
            return resolve();
          });
        }
      });
    });
  };
  // Local execution for callbacks
  callback_local = function(context, callback, next) {
    callback.call(context, null, next);
    return null;
  };
  // Remote execution for callbacks
  callback_remote = function(context, callback, next) {
    if (config.host == null) {
      config.host = 'localhost';
    }
    return connect(config, function(err, ssh) {
      if (err) {
        return next(err);
      }
      return callback.call(context, ssh, function(err) {
        var open, ref, ref1;
        open = ((ref = ssh._sshstream) != null ? ref.writable : void 0) && ((ref1 = ssh._sock) != null ? ref1.writable : void 0);
        if (!open) {
          return next();
        }
        ssh.end();
        return ssh.on('end', function() {
          return process.nextTick(function() {
            return next(err);
          });
        });
      });
    });
  };
  // Define our main entry point
  they = function(msg, callback) {
    var k, l, len1, len2, results, results1;
    if (callback.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        if (!config.ssh) {
          results.push(it(`${msg} (${config.name})`, function() {
            return promise_local(this, callback);
          }));
        } else {
          results.push(it(`${msg} (${config.name})`, function() {
            return promise_remote(this, callback);
          }));
        }
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        if (!config.ssh) {
          results1.push(it(`${msg} (${config.name})`, function(next) {
            return callback_local(this, callback, next);
          }));
        } else {
          results1.push(it(`${msg} (${config.name})`, function(next) {
            return callback_remote(this, callback, next);
          }));
        }
      }
      return results1;
    }
  };
  they.only = function(msg, callback) {
    var k, l, len1, len2, results, results1;
    if (callback.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        if (!config.ssh) {
          results.push(it.only(`${msg} (${config.name})`, function() {
            return promise_local(this, callback);
          }));
        } else {
          results.push(it.only(`${msg} (${config.name})`, function() {
            return promise_remote(this, callback);
          }));
        }
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        if (!config.ssh) {
          results1.push(it.only(`${msg} (${config.name})`, function(next) {
            return callback_local(this, callback, next);
          }));
        } else {
          results1.push(it.only(`${msg} (${config.name})`, function(next) {
            return callback_remote(this, callback, next);
          }));
        }
      }
      return results1;
    }
  };
  they.skip = function(msg, callback) {
    var k, l, len1, len2, results, results1;
    if (callback.length === 1) {
      results = [];
      for (i = k = 0, len1 = configs.length; k < len1; i = ++k) {
        config = configs[i];
        if (!config.ssh) {
          results.push(it.skip(`${msg} (${config.name})`, function() {
            return promise_local(this, callback);
          }));
        } else {
          results.push(it.skip(`${msg} (${config.name})`, function() {
            return promise_remote(this, callback);
          }));
        }
      }
      return results;
    } else {
      results1 = [];
      for (i = l = 0, len2 = configs.length; l < len2; i = ++l) {
        config = configs[i];
        if (!config.ssh) {
          results1.push(it.skip(`${msg} (${config.name})`, function(next) {
            return callback_local(this, callback, next);
          }));
        } else {
          results1.push(it.skip(`${msg} (${config.name})`, function(next) {
            return callback_remote(this, callback, next);
          }));
        }
      }
      return results1;
    }
  };
  // Return the final result
  return they;
};

module.exports = configure();

module.exports.configure = function(...configs) {
  return configure(...configs);
};
